package hr.fer.zemris.optjava.dz2;

import Jama.Matrix;

public class NumOptAlgorithms {
	
	public static Matrix gradDescentAlg(IFunction function, long maxIter, Matrix x0) {
		int numOfVariables = function.getNumberOfVariables();
		Matrix x = x0;
		for(int i = 0; i < maxIter; i++) {
			Matrix grad = function.getGrad(x);
			if(isNullVector(grad)) {
				return function.value(x);
			}
			
			double lambda = 0.0;
			double lambdaLower = 0.0;
			double lambdaUpper = 1.0;
			
			double dThetadLambda = derivateTheta(function, grad, x, lambdaUpper);
			while(dThetadLambda < 0.0) {
				lambdaUpper *= 2;
				dThetadLambda = derivateTheta(function, grad, x, lambdaUpper);
			}
			while(Math.abs(lambdaUpper - lambdaLower) < 10e-3) {
				lambda = (lambdaLower + lambdaUpper) / 2;
				dThetadLambda = derivateTheta(function, grad, x, lambda);
				if(Math.abs(dThetadLambda) < 10e-3) {
					break;
				} else if (dThetadLambda > 0) {
					lambdaUpper = lambda;
				} else if(dThetadLambda < 0) {
					lambdaLower = lambda;
				}
			}
			
			//TODO
			
			// x = x - lambda * grad
			x = x.minus(grad.times(lambda));
			
		}
		return null;
	}
	
	private static double derivateTheta(IFunction function, Matrix grad, Matrix x, double lambda) {
		// xShift = x + lambdaUpper * grad
		Matrix xShift = x.plus(grad.times(lambda));		// N x 1
		Matrix gradShift = function.getGrad(xShift);	// N x 1
		
		// (1 x N) * (N x 1) = (1 x 1)
		Matrix dThetadLambda = gradShift.transpose().times(grad).times(-1); //scalar
		return dThetadLambda.get(0, 0);
	}
	
	private static boolean isNullVector(Matrix vector) {
		int n = vector.getRowDimension();
		boolean isNullVector = true;
		for(int i = 0; i < n; i++) {
			if(Math.abs(vector.get(i, 0)) > 10e-3) {
				isNullVector = false;
			}
		}
		return isNullVector;
	}
}
